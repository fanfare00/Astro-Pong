<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ball_neutral_James</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize most variables for logic
lightPink = merge_color(c_white, c_fuchsia, 0.1)
lightGreen = merge_color(c_white, c_green, 0.1)

instance_create(0,0, obj_particle_trail_James);



ballColor = "yellow";

//controls angle of ball when it hits the paddle
yDifferencePlayer = 0;
yDifferenceEnemy = 0;

//serve ball at random angle
vsp = random(20)-10;

//send ball in direction of person who last scored

if (global.playerScored == true)
{
    hsp = -15;
}
else
{
    hsp = 15;
}

explosionX = 0;
explosionY = 0;

explode = false;

explodeDirection = "default";

shrapnelDistance = 0;
shrapnelAnimation = 0;

whoExploded = "defalt";


timesChecked = 0;

orbitDirection = 0;

drawEnergyLoss = false;

fadeText = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///stop draw - 50 energy after 5 seconds



    drawEnergyLoss = false;
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///all collisions and actions involving the ball
yDifferencePlayer = obj_ball_James.y - obj_paddle_player_James.y;
yDifferenceEnemy = obj_ball_James.y - obj_paddle_enemy_James.y;
ballAtEnemy = (sign(hsp));

if (global.playerScore == 10) or (global.enemyScore == 10)
{
    var endGame;
    instance_create(0,0, obj_pause_menu_James);

    exit;
    
}



//handle creation of other units
if !instance_exists(obj_UFO_James)
{

        instance_create( 100, 100, obj_UFO_James);
    
}

if !instance_exists(obj_sun_James)
{

        instance_create( 100, 100, obj_sun_James);
    
}

if !instance_exists(obj_asteroid_James) and !floor(random(100))
{

        instance_create( 0, 0, obj_asteroid_James);
    
}

//horizontal collision
//if we're about to hit a wall (place_meeting with x+hsp checks the future)
//sign returns either 1 or -1 depending on whether the value inside
//is positive or negative, so we can check left or right simultaneously
//if future collision is detected, move 1 pixel at a time (sign returns +1 or -1
//depending on whether the number inside is positive or negative) as close 
//as possible to wall without going through

//collision left/right
if (place_meeting(x+hsp, y, obj_paddle_player_James)) or (place_meeting(x+hsp, y, obj_paddle_enemy_James))
{
    timesChecked = 0;
    
    if speed &gt; 0
    {
        hsp = speed;
        speed = 0;
    }

    //left paddle
    if (ballAtEnemy == -1)
    {

        
        //depending where the ball hits on the paddle, give a verticle bounce
        vsp = ((yDifferencePlayer) / 2.5) * (abs(hsp / 15));
                //max value is like 65, min is like 0 for yDifference
        
     //these two ifs are to give the ball more bounce towards the middle
        if (sign(yDifferencePlayer) == -1) &amp;&amp; (yDifferencePlayer &gt; -30) &amp;&amp; (yDifferencePlayer &lt; -15)
        {
            vsp -= 5;
        }
        else if (sign(yDifferencePlayer) == 1) &amp;&amp; (yDifferencePlayer &lt; 30) &amp;&amp; (yDifferencePlayer &gt; 15)
        {
            vsp += 5;
        }
        //increase ball speed by one in player direction before turning it around
        hsp-=1;
        
        //set trail color
        part_type_color_mix(obj_particle_trail_James.flare, c_aqua, c_white); 
        part_type_color_mix(obj_particle_trail_James.bloom, c_aqua, c_blue); 
        
        //set bounce blast color
        part_type_color_mix(obj_particle_trail_James.radiate, c_aqua, c_aqua);
        
        //set ball color
        ballColor = "blue";
        
        //paddle visual feedback from collision
        obj_paddle_player_James.sprite_index = spr_bounce_James;
        
        
    }
    
    //right paddle
    if (ballAtEnemy == 1)
    {

    
        //depending where the ball hits on the paddle, give a verticle bounce
        vsp = (yDifferenceEnemy) / 2.5 * (abs(hsp / 15));;
    
        //these two ifs are to give the ball more bounce towards the middle
        if (sign(yDifferenceEnemy) == -1) &amp;&amp; (yDifferenceEnemy &gt; -40)
        {
            vsp -= 5;
        }
        else if (sign(yDifferenceEnemy) == 1) &amp;&amp; (yDifferenceEnemy &lt; 40)
        {
            vsp += 5;
        }
        //increase ball speed by 1 in enemy direction before bouncing it
        hsp+=1;
        
        //set trail color
        part_type_color_mix(obj_particle_trail_James.flare, c_fuchsia, lightPink);
        part_type_color_mix(obj_particle_trail_James.bloom, c_fuchsia, lightPink);
        
        //set bounce blast color
        part_type_color_mix(obj_particle_trail_James.radiate, c_fuchsia, c_fuchsia);
        
        //set ball color
        ballColor = "pink"; 
        
        //paddle visual feedback from collision
        obj_paddle_enemy_James.sprite_index = spr_bounce_enemy_James;
          
    }
    
    //if chargin up and ball is at player paddle
    if (global.holdGlow == true) and (ballAtEnemy == -1)
    {
        //prevent ball from being slowed by charge if its a weak charge
         if abs(hsp) &lt; (obj_interface_James.chargeMeter * 0.15)
         { 
            move_towards_point( mouse_x, mouse_y, obj_interface_James.chargeMeter * 0.14);
            
                //do some particle effects so player knows they got a charged shot
            
            //a little less subtle blast effect than used for top/bottom collision
            part_type_alpha3( obj_particle_trail_James.radiate, 1, obj_interface_James.chargeMeter * 0.002, 0); 
            part_type_shape(obj_particle_trail_James.radiate, pt_shape_flare);
            
            //blast when ball strikes charged paddle
            part_emitter_region(obj_particle_trail_James.blast,obj_particle_trail_James.blast_emitter,  x, x , y, y, ps_shape_ellipse, ps_distr_gaussian);
            part_emitter_burst(obj_particle_trail_James.blast, obj_particle_trail_James.blast_emitter, obj_particle_trail_James.radiate, 1); 
            
            //play fully charged shot sound
            audio_play_sound (snd_discharge_James, 11, false);
            
         }
         else
         {
            move_towards_point( mouse_x, mouse_y, abs(hsp));
         }
        
        //subtract power, but not more than the player has
        obj_interface_James.powerLevel -= 150;
        
        drawEnergyLoss = true;
        alarm[0] = 150;
        
        if obj_interface_James.powerLevel &lt; 0
        {
            obj_interface_James.powerLevel = 0;
        }
        
        hsp = (hsp - (2 * hsp));
         
        vsp = hsp * ((obj_paddle_enemy_James.y - mouse_y) / (obj_paddle_player_James.x - mouse_x));      
    }
    else   
    {
        hsp = (hsp - (2 * hsp));
        audio_play_sound(snd_laser_James, 10, false);
    }
}

//verticle speed limit up/down
if (vsp &gt; 20)
{
    vsp = 20;
}

if (vsp &lt; -20)
{
    vsp = -20;
}

//another speed limit
if (speed &gt; 40)
{
    speed = 40;
}

if (speed &lt; -40)
{
    speed = -40;
}



//collision bottom/top
if place_meeting(x+hsp, y+vsp, obj_boundary_bottom_James) or place_meeting(x+hsp, y+vsp, obj_boundary_top_James)
{
    timesChecked = 0;

    if speed &gt; 0
    {
        hsp = speed;
        vsp = vspeed;
        speed = 0;
    }
    part_type_alpha3( obj_particle_trail_James.radiate, 1, 0.3, 0); 
    part_type_shape(obj_particle_trail_James.radiate, pt_shape_ring);
    part_emitter_region(obj_particle_trail_James.blast,obj_particle_trail_James.blast_emitter,  x, x , y, y, ps_shape_ellipse, ps_distr_gaussian);
    part_emitter_burst(obj_particle_trail_James.blast, obj_particle_trail_James.blast_emitter, obj_particle_trail_James.radiate, 1); 
    
    vsp = (vsp - (2 * vsp));
    
   audio_play_sound (snd_bounce_James, 10, false);
}

//if (point_distance(obj_sun_James.x, obj_sun_James.y, x + hsp, y + hsp) &lt; 145)
//{
   // vsp += sign(vsp);
//}



//UFO collision
if (place_meeting(x+hsp, y+vsp, obj_UFO_James) and !(x &gt; 1024) and !(x &lt; 0) and (y &gt; 100) and (y &lt; 615))
{
    //change the ball to be green
    ballColor = "green";

    //set the ball trail to be green
    part_type_color_mix(obj_particle_trail_James.flare, c_lime, c_white);
    part_type_color_mix(obj_particle_trail_James.bloom, c_lime, c_white);
    
    //reverse vertical direction and increase speed by 2
    vsp = (vsp - (3 * vsp));
    hsp += sign(hsp) * 2;
    
    timesChecked = 0;
    
        if !audio_is_playing(snd_UFO_James)
    {
        audio_play_sound(snd_UFO_James, 9, false);  
        
    }
}

//Asteroid collision
if (place_meeting(x+hsp, y+vsp, obj_asteroid_James) and !(x &gt; 1024) and !(x &lt; 0) and (y &gt; 100) and (y &lt; 615))
{
    asteroid_explode();
    

    with (obj_asteroid_James)
    {       
        instance_destroy();
    }


}
        


if (x &gt; 1024)
{
         if !audio_is_playing(snd_ding_win_James)
         {
        //play winning sound
            audio_play_sound(snd_ding_win_James, 10, false);
         }
} 

if (x &lt; 0)
{
        if !audio_is_playing(snd_ding_loss_James)
        {
        //play losing sound
            audio_play_sound(snd_ding_loss_James, 10, false); 
        }

}
//if ball goes out on enemy side
//higher value than 1024 so there's a slight delay
if (x &gt; 1324)
{              


        //destroy winning ball
        instance_destroy();
        
        //destroy particle effects
        with (obj_particle_trail_James ) {instance_destroy();}
  
        //give player +1 score
        global.playerScore+=1;
        
        //tell ball which way to serve
        global.playerScored = true;
        
        //create a new ball
        instance_create(512,334,obj_ball_James);
}


//if ball goes out on player side
if (x &lt; -300)
{


        //destroy winning ball
        instance_destroy();
        
        //destroy particle effects
        with (obj_particle_trail_James) {instance_destroy();}
        
        //add one to enemy score
        global.enemyScore+=1;
        
        //tell the ball which direction to serve
        global.playerScored = false;
        
        //create the new ball
        instance_create(512,334,obj_ball_James);
}

//using move to point which requires speed, but when im done with that return to using hsp/vsp variables
if speed == 0
{
    x+=hsp;
    y+=vsp;
}

//if the ball is 
if (distance_to_point(obj_sun_James.x, obj_sun_James.y) &lt; 150 + abs(hsp)) and  (distance_to_point(obj_sun_James.x, obj_sun_James.y) &gt; 150 - abs(hsp))
{
    //ball headed right
    if sign(hsp) == 1 and timesChecked == 0
    {
        //for loop that checks all values of x along the balls intended path
        for (var i = 1; i &lt; 20; i++)
        {
            //when x of ball = x of sun, store y of sun - y of ball
            if abs(obj_sun_James.x - (x + hsp * i)) &lt; hsp
            {
                orbitDirection = (obj_sun_James.y) - (y + vsp * i);
                //only run for loop once and end when getting a value
                timesChecked = 1;
                i = 19;
            }
        }
    }
    //ball headed left
    if sign(hsp) == -1 and timesChecked == 0
    {
        for (var i = 1; i &lt; 20; i++)
        {
            if obj_sun_James.x - (x + hsp * i) &gt; hsp
            {
                orbitDirection = (obj_sun_James.y) - (y + vsp * i);
                timesChecked = 1;
                i = 19;
            }
        }    
    }
    
}

if (distance_to_point(obj_sun_James.x, obj_sun_James.y) &lt; 150)
{

    sun_effect();
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_ball_James</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///decide which color ball is, draw particle effects
switch (ballColor)
    {
    case "yellow":
        draw_sprite(spr_ball_neutral_James, 0, x, y);
        part_type_color_mix(obj_particle_trail_James.flare, c_olive, c_white); 
        part_type_color_mix(obj_particle_trail_James.bloom, c_yellow, c_white);
        break;
        
    case "blue":
        draw_sprite(spr_ball_player_James, 0, x, y);
        break;
        
    case "pink":
        draw_sprite(spr_ball_enemy_James, 0, x, y);
        break;
        
    case "green":
        draw_sprite(spr_ball_UFO_James, 0, x, y);
        break;
        
    }


    //tell user hes out of energy when he tries to use charge with 0 energy
    //should be in interface, but I need it to be at a higher depth
if (obj_interface_James.powerLevel == 0) and (keyboard_check(vk_space))
{

    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    draw_set_color(c_red);
    draw_set_font(fnt_menu_score_James);
    draw_text_transformed(511, 300, "Not enough energy!", 0.25, 0.25, 0);

}

if (drawEnergyLoss == true)
{ 
    fadeText-=0.035;
        
    draw_set_color(c_red);
    draw_set_font(fnt_menu_score_James);
    draw_set_alpha(fadeText);
    draw_text_transformed(obj_paddle_player_James.x + 150 + 5/fadeText, obj_paddle_player_James.y- 5/fadeText, "- 50 energy", 0.19, 0.19, 0);
}

//stream particles from the back of ball
part_emitter_region(obj_particle_trail_James.trail, obj_particle_trail_James.trail_emitter, x + (hsp*1.2), x - (hsp), y+ (vsp*1.2), y - (vsp), ps_shape_line, ps_distr_gaussian);
part_emitter_stream(obj_particle_trail_James.trail,obj_particle_trail_James.trail_emitter, obj_particle_trail_James.flare, 5);

part_emitter_region(obj_particle_trail_James.bounce, obj_particle_trail_James.bounce_emitter,  x, x - (hsp), y, y - (vsp), ps_shape_line, ps_distr_gaussian);
part_emitter_stream(obj_particle_trail_James.bounce,obj_particle_trail_James.bounce_emitter, obj_particle_trail_James.bloom, 15);

if explode == true
{
    //little asteroids shoot out from explosion epicenter
    shrapnelDistance += 5;
    //have to manually cycle through the frames for some reason
    shrapnelAnimation +=1;
    
    //just draws +50 energy in the color of player, text grows bigger, fades out
    if (shrapnelDistance &lt; 300) and (whoExploded == "player")
    {
        draw_set_font(fnt_menu_score_James);
        draw_text_transformed_color(explosionX, explosionY, "+50 Energy", 0.132 + (.001 * shrapnelDistance), 0.165 + (.001 * shrapnelDistance), 0, c_aqua , c_aqua, c_teal, c_teal, (1.2 - shrapnelDistance * .005));
        
    }
    //same thing but for computer
    if (shrapnelDistance &lt; 300) and (whoExploded == "enemy")
    {
        draw_set_font(fnt_menu_score_James);
        draw_text_transformed_color(explosionX, explosionY, "+50 Energy", 0.132 + (.001 * shrapnelDistance), 0.165 + (.001 * shrapnelDistance), 0, c_fuchsia , c_fuchsia, c_purple, c_purple, (1.2 - shrapnelDistance * .005));    
    }
    //needed to cycle through the animation because it wont animate in the standard way
    if shrapnelAnimation &gt;=12
    {
        shrapnelAnimation = 0;
    }
    

    //depending on where the asteroid was struck, do different things with the shrapnel, idk why I did this
    switch (explodeDirection)
    {   
        //shoot 3 smaller asteroids
        case "upLeft":
            //asteroid moving to the top right of the screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + shrapnelDistance, explosionY - shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
           
            //asteroid moving straight down
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + 0, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
           
            //asteroid moving to the bottom left of the screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX - shrapnelDistance, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );  
            break;
        
        case "upRight":          
            //asteroid moving towards top left of the screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX - shrapnelDistance, explosionY - shrapnelDistance, 0.5, 0.5, 45, -1, 1 ); 
            
            //asteroid moving straight down
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + 0, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            
            //asteroid moving towards bottom right of screen
           draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + shrapnelDistance, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );       
            break;
        
        case "lowerLeft":           
            //asteroid straight up
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + 0, explosionY -shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            
            //asteroid moving to bottom right of screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + shrapnelDistance, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            
            //asteroid moving to top left of screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX - shrapnelDistance, explosionY - shrapnelDistance, 0.5, 0.5, 45, -1, 1 );  
            break;
            
        case "lowerRight":
            //asteroid moving to top right of screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + shrapnelDistance, explosionY - shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            
            //asteroid moving straight up
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX + 0, explosionY -shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            
           // asteroid moving to bottom left of screen
            draw_sprite_ext( spr_asteroid_James, shrapnelAnimation, explosionX - shrapnelDistance, explosionY + shrapnelDistance, 0.5, 0.5, 45, -1, 1 );
            break;   
    }
    //get rid of shrapnel when its all over
    if (shrapnelDistance + explosionX &gt; 1024) or (shrapnelDistance + explosionY &gt; 768) or (explosionY - shrapnelDistance &lt; 0) or (explosionX - shrapnelDistance  &lt; 0)
    {
       
        explode = false;
        shrapnelAnimation = 0;
        shrapnelDistance = 0;
    }
}




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
